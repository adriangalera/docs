"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4257],{7483:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Hacking/HTB Academy/Android Fundamentals","title":"Android Fundamentals","description":"Android is a mobile operating system created for touchscreen devices like phones and tablets. Based on a modified version of the Linux Kernel.","source":"@site/docs/Hacking/HTB Academy/Android Fundamentals.md","sourceDirName":"Hacking/HTB Academy","slug":"/Hacking/HTB Academy/Android Fundamentals","permalink":"/docs/Hacking/HTB Academy/Android Fundamentals","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Reference","permalink":"/docs/flight-sim/dcs/su25t"},"next":{"title":"File inclusion","permalink":"/docs/Hacking/HTB Academy/File inclusion"}}');var s=i(4848),a=i(8453);const r={},o="Android Fundamentals",d={},c=[{value:"Software stack",id:"software-stack",level:2},{value:"Rooting",id:"rooting",level:2},{value:"Import directories",id:"import-directories",level:2},{value:"Android Security",id:"android-security",level:2},{value:"APK Structure",id:"apk-structure",level:2},{value:"Types of application",id:"types-of-application",level:2},{value:"Android Application Components and IPC",id:"android-application-components-and-ipc",level:2},{value:"Activities",id:"activities",level:3},{value:"Services",id:"services",level:3},{value:"Broadcast receivers",id:"broadcast-receivers",level:3},{value:"Content Providers",id:"content-providers",level:3},{value:"Intents",id:"intents",level:3},{value:"Binders",id:"binders",level:3},{value:"Deep links",id:"deep-links",level:3},{value:"Android Debug Bride",id:"android-debug-bride",level:3},{value:"Android penetration testing",id:"android-penetration-testing",level:3}];function l(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"android-fundamentals",children:"Android Fundamentals"})}),"\n",(0,s.jsx)(n.p,{children:"Android is a mobile operating system created for touchscreen devices like phones and tablets. Based on a modified version of the Linux Kernel."}),"\n",(0,s.jsx)(n.p,{children:"As we mentioned in the previous section, Android is a Linux-Based OS, and once someone gains access to a shell on the device, Linux commands can be executed."}),"\n",(0,s.jsx)(n.h2,{id:"software-stack",children:"Software stack"}),"\n",(0,s.jsx)(n.p,{children:"From lower level to higher level:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Linux kernel: managing device hardware such as the display, camera, bluetooth, wifi, audio, USB, and more. Threading and memory management. Also numerous security features (user-based permissions and process isolation)."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Hardware Abstraction Layer (HAL): standardized interface for interacting with hardware components, such as cameras, Bluetooth, sensors, and input devices. Acting as a bridge between hardware and the higher-level software layers, HAL ensures consistency in how software accesses hardware features. Given the different amount of hardware sensors, software needs to find a common interface to interact with the hardware."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Android Runtime: Android Runtime (ART) is the managed runtime environment used by the Android operating system to execute applications. Application code is compiled into native machine code at install time. This is like the JVM but for Android, e.g: performs garbage collection, memory management, etc.."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Native C/C++ libraries: Developers generally use these libraries to achieve high performance or write low-level code to interact directly with the hardware."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Java API Framework: This component provides software tools and interfaces for building Android applications."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"System apps: This component includes all the pre-installed applications that come with the Android operating system."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"rooting",children:"Rooting"}),"\n",(0,s.jsxs)(n.p,{children:["Android separates the flash storage into the following two main partitions : ",(0,s.jsx)(n.code,{children:"/system"})," and ",(0,s.jsx)(n.code,{children:"/data"}),". The partition ",(0,s.jsx)(n.code,{children:"/system/"})," is used by the operating system, and the partition ",(0,s.jsx)(n.code,{children:"/data/"})," is used for user data and application installations."]}),"\n",(0,s.jsx)(n.p,{children:"In Android, users don't have root access to the operating system, and some partitions (like /system/) are read-only."}),"\n",(0,s.jsxs)(n.p,{children:["In order to have full ",(0,s.jsx)(n.code,{children:"root"})," access to the device, you need to exploit some security flaws, this process is called ",(0,s.jsx)(n.code,{children:"Rooting"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"import-directories",children:"Import directories"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Directory"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/data/data"}),(0,s.jsx)(n.td,{children:"Contains all the applications that are installed by the user"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/data/user/0"}),(0,s.jsx)(n.td,{children:"Contains data that only the app can access"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/data/app"}),(0,s.jsx)(n.td,{children:"Contains the APKs of the applications that are installed by the user"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/system/app"}),(0,s.jsx)(n.td,{children:"Contains the pre-installed applications of the device"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/system/bin"}),(0,s.jsx)(n.td,{children:"Contains binary files"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/data/local/tmp"}),(0,s.jsx)(n.td,{children:"A world-writable directory"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/data/system"}),(0,s.jsx)(n.td,{children:"Contains system configuration files"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/etc/apns-conf.xml"}),(0,s.jsx)(n.td,{children:"Contains the default Access Point Name (APN) configurations. APN is used in order for the device to connect with the carrier"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/data/misc/wifi"}),(0,s.jsx)(n.td,{children:"Contains WiFi configuration files"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/data/misc/user/0/cacerts-added"}),(0,s.jsx)(n.td,{children:"User certificate store. It contains certificates added by the user"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/etc/security/cacerts/"}),(0,s.jsx)(n.td,{children:"System certificate store. Permission to non-root users is not permitted"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"/sdcard"}),(0,s.jsx)(n.td,{children:"Contains a symbolic link to the directories DCIM, Downloads, Music, Pictures, etc."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"android-security",children:"Android Security"}),"\n",(0,s.jsx)(n.p,{children:"Kotlin and Java are the two primary languages used to develop Android applications. The Android SDK tools compile application source code along with resource files and assets into an Android Package (APK). An APK is an archive file with a .apk extension that contains all the components needed to install and run an Android app, including compiled bytecode (.dex), manifest metadata, resources, and native libraries."}),"\n",(0,s.jsx)(n.p,{children:"Each Android application runs within its own isolated security sandbox, enforced by the underlying Linux-based architecture. This sandboxing model is supported by several core Android security features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Android is a multi-user Linux system where each application is treated as a separate user."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"By default, the system assigns each app a unique Linux user ID (UID). This UID is used by the system for access control, but is not exposed to the app itself."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"File system permissions ensure that only the app assigned a particular UID can access its own files."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Each app runs in its own process, and each process runs in a separate instance of the Android Runtime (ART) virtual machine, ensuring memory isolation."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The system launches the app's process as needed and terminates it when no longer required or when reclaiming system resources."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Android enforces the principle of least privilege, meaning apps only receive the permissions necessary to perform their core functionality. Additional privileges must be explicitly declared in the app's manifest and approved by the user (or system, depending on the API level)."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Android uses Linux\u2019s user-based security model to isolate applications by assigning each app a unique user ID (UID) and running it in its own process. This creates a kernel-level application sandbox that enforces strict boundaries between apps and the system, preventing unauthorized data access or code execution across app boundaries."}),"\n",(0,s.jsx)(n.p,{children:"Escaping this sandbox requires compromising the kernel itself, typically through a privilege escalation exploit."}),"\n",(0,s.jsx)(n.p,{children:"We can see this, when we list the files:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"root:/# ls -l /data/data/\n\ndrwx------  4 system         system         4096 2022-12-28 11:47 android\ndrwx------  4 bluetooth      bluetooth      4096 2022-12-28 11:47 com.android.bluetooth\ndrwx------  5 radio          radio          4096 2022-12-28 11:48 com.android.ons\ndrwx------  5 shell          shell          4096 2022-12-28 11:49 com.android.shell\ndrwx------ 11 u0_a114        u0_a114        4096 2022-12-30 12:41 com.android.chrome\ndrwx------  5 u0_a119        u0_a119        4096 2022-12-28 11:49 com.android.camera2\n"})}),"\n",(0,s.jsx)(n.p,{children:"To install an application on a device or upload it to the Play Store, the APK file must be signed. Signing the APK is crucial for security, as it protects the package from malicious modifications."}),"\n",(0,s.jsx)(n.p,{children:"The certificates that are used to sign an application are self-signed. One can sign an APK file with apksigner tool (Signature Scheme v4) using the following commands:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'echo -e "password\\npassword\\njohn doe\\ntest\\ntest\\ntest\\ntest\\ntest\\nyes" > params.txt\ncat params.txt | keytool -genkey -keystore key.keystore -validity 1000 -keyalg RSA -alias john\nzipalign -p -f -v 4 myapp.apk myapp_signed.apk\necho password | apksigner sign --ks key.keystore myapp_signed.apk\n'})}),"\n",(0,s.jsx)(n.p,{children:"Verified Boot is an Android security feature that ensures the integrity of the operating system. This is achieved using a unique set of cryptographic keys to sign and verify the boot image and ensure that only the authorized parties can modify the system"}),"\n",(0,s.jsx)(n.h2,{id:"apk-structure",children:"APK Structure"}),"\n",(0,s.jsxs)(n.p,{children:["The Android Package Kit file\u2014commonly known as an APK\u2014is the file format used by the Android operating system to distribute and install applications. An APK is essentially an archive that contains all the components needed for an Android app to run. It is based on ",(0,s.jsx)(n.code,{children:"zip"}),", therefore it can be unzipped:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"adriangalera@htb[/htb]$ unzip myapp.apk\nadriangalera@htb[/htb]$ ls -l\n\ntotal 27584\n-rw-r--r--    1 bertolis  bertolis     4220 Jan  1  1981 AndroidManifest.xml\ndrwxr-xr-x   49 bertolis  bertolis     1568 May 10 13:36 META-INF\ndrwxr-xr-x    3 bertolis  bertolis       96 May 10 13:36 assets\n-rw-r--r--    1 bertolis  bertolis  8285624 Jan  1  1981 classes.dex # contains the application code\ndrwxr-xr-x    9 bertolis  bertolis      288 May 10 13:36 kotlin\ndrwxr-xr-x    6 bertolis  bertolis      192 May 10 13:36 lib\ndrwxr-xr-x  545 bertolis  bertolis    17440 May 10 13:36 res\n-rw-r--r--    1 bertolis  bertolis   922940 Jan  1  1981 resources.arsc\n"})}),"\n",(0,s.jsx)(n.p,{children:"The files extracted from the APK are encoded, and neither the source code nor the configuration files are human-readable."}),"\n",(0,s.jsx)(n.p,{children:"Let's deep dive:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"META-INF: contains verification information"}),"\n",(0,s.jsx)(n.li,{children:"assets: This folder contains assets that developers bundle with the application, and can be retrieved by the AssetManager."}),"\n",(0,s.jsx)(n.li,{children:"lib: This folder contains native libraries with compiled code targeting different device architectures. Android applications that use the Native Development Kit (NDK) may include components written in C or C++."}),"\n",(0,s.jsx)(n.li,{children:"res: This folder contains predefined application resources that cannot be modified by the user at runtime, unlike assets. These resources include XML files defining color state lists, UI layouts, fonts, values, configurations for OS versions, screen orientations, network settings, and more."}),"\n",(0,s.jsx)(n.li,{children:"AndroidManifest.xml: metadata about the application."}),"\n",(0,s.jsx)(n.li,{children:"classes.dex: This file contains all compiled Java (or Kotlin) classes in DEX (Dalvik Executable) format, which are executed by the Android Runtime (ART)."}),"\n",(0,s.jsx)(n.li,{children:"resources.arsc: This file contains precompiled resources that are used by the app at runtime. It maps resource identifiers in the code (e.g., R.string.app_name) to their actual values, such as strings, colors, layouts, and styles."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"types-of-application",children:"Types of application"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Native: direct access to platform. Built with Kotlin or Java."}),"\n",(0,s.jsx)(n.li,{children:"Web apps: developed to be responsive and accessible from mobile web browsers. They are typically built using HTML, CSS, and JavaScript."}),"\n",(0,s.jsx)(n.li,{children:"Hybrid apps: Hybrid apps combine elements of both native and web apps and are designed to be cross-platform. They use WebViews to display web content within a native app container."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"android-application-components-and-ipc",children:"Android Application Components and IPC"}),"\n",(0,s.jsx)(n.p,{children:"Application components are the building blocks that define different parts of an Android application, such as the user interface and core functionality. These components are declared in the AndroidManifest.xml and can be used individually or in tandem with one another. Interprocess Communication (IPC) is a mechanism that allows for communication between applications or different processes within the same application."}),"\n",(0,s.jsx)(n.h3,{id:"activities",children:"Activities"}),"\n",(0,s.jsx)(n.p,{children:"Activities are a fundamental application component, representing a single screen with a user interface. An Activity is the main component that allows the interaction between the user and the app, and can be started by other Activities, apps, or system events."}),"\n",(0,s.jsx)(n.p,{children:"The Android operating system maintains an Activity stack as part of the task that the app belongs to. When a new Activity is launched, it's placed on top of the stack and becomes the active Activity. The previous Activity is paused and remains in the stack."}),"\n",(0,s.jsx)(n.p,{children:"Activities are declared in AndroidManifest.xml and can be exported so that other apps can use the activity."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["The exported attribute can be set on ",(0,s.jsx)(n.code,{children:"<activity>, <service>, <receiver>, and <provider>"})," elements in the AndroidManifest.xml file."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"services",children:"Services"}),"\n",(0,s.jsx)(n.p,{children:"A Service is an Android application component that performs long-running operations in the background without providing a user interface. Services can be used for tasks like downloading files, playing music, or communicating with a remote server, and can continue working even after the user has left the app."}),"\n",(0,s.jsx)(n.p,{children:"There are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Foreground services: Foreground services perform operations that require user attention. Will generate notifications, e.g: media players or navigation apps."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Background services: perform operations that do not require user interaction."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Bound services: They provide a client-server interface that enables components\u2014even across different processes\u2014to interact with the service using Interprocess Communication (IPC)."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"broadcast-receivers",children:"Broadcast receivers"}),"\n",(0,s.jsx)(n.p,{children:"Broadcast Receivers can be considered as both Application Components and Interprocess Communication (IPC) mechanisms."}),"\n",(0,s.jsx)(n.p,{children:"As an IPC mechanism, Broadcast Receivers enable communication between different applications by sending and receiving Intents. These Intents can be sent by the Android system, other apps, or the app itself."}),"\n",(0,s.jsx)(n.p,{children:"As an Application Component, Broadcast Receivers are designed to respond to system-wide or custom events broadcasted by other applications."}),"\n",(0,s.jsx)(n.h3,{id:"content-providers",children:"Content Providers"}),"\n",(0,s.jsx)(n.p,{children:"As an IPC mechanism, Content Providers enable communication between applications by allowing them to access, modify, or delete data using a consistent interface through the ContentResolver class."}),"\n",(0,s.jsx)(n.p,{children:"As an application component, Content Providers are responsible for managing and exposing data structures within or to other apps."}),"\n",(0,s.jsx)(n.p,{children:"They allow data sharing inside or outside the application."}),"\n",(0,s.jsx)(n.h3,{id:"intents",children:"Intents"}),"\n",(0,s.jsx)(n.p,{children:"Messaging objects used by applications or the Android system to request actions from other components such as Activities, Services, and Broadcast receivers. While Intents are not primarily designed for Interprocess Communication (IPC), they may be used when an application wants to interact with a component (such as a service) that resides in a different process."}),"\n",(0,s.jsx)(n.p,{children:"Typical use cases are:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Starting an activity:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Intent intent = new Intent(this, ContactDetailActivity.class);\nintent.putExtra("contact_id", selectedContactId);\nstartActivity(intent);\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"Starting a service:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Intent intent = new Intent(this, DownloadService.class);\nintent.putExtra("file_url", fileUrl);\nstartService(intent);\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"Deliver a broadcast message:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Intent intent = new Intent("com.example.ACTION_BATTERY_LOW");\nsendBroadcast(intent);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We can define ",(0,s.jsx)(n.code,{children:"explicit"})," intents such as:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"Intent intent = new Intent(this, TargetActivity.class);\nstartActivity(intent); \n"})}),"\n",(0,s.jsx)(n.p,{children:"which is used to navigate inside the app. The class has to be known."}),"\n",(0,s.jsxs)(n.p,{children:["or ",(0,s.jsx)(n.code,{children:"implicit"})," intents, where we don't know exactly the class but we rely on the system to find a suitable actor to perform an action:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Intent intent = new Intent(Intent.ACTION_VIEW);\nintent.setData(Uri.parse("https://www.example.com"));\nstartActivity(intent);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Intents can have data using the ",(0,s.jsx)(n.code,{children:"putExtra"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'Intent intent = new Intent(this, TargetActivity.class);\nintent.putExtra("key", "value");\nstartActivity(intent);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"binders",children:"Binders"}),"\n",(0,s.jsx)(n.p,{children:"The Binder is Android's core Interprocess Communication (IPC) mechanism, enabling efficient and secure communication between different processes."}),"\n",(0,s.jsx)(n.p,{children:"It allows a client process to invoke methods on a remote object located in another process (but owned by the same application) as if the object were local."}),"\n",(0,s.jsx)(n.h3,{id:"deep-links",children:"Deep links"}),"\n",(0,s.jsx)(n.p,{children:"A Deep Link is an Interprocess Communication (IPC) mechanism that allows users to navigate directly to specific content within an app."}),"\n",(0,s.jsx)(n.p,{children:"For example, a user might receive a promotional email about a flash sale on a specific product. Instead of directing the user to the website, the link opens the corresponding app to display the product."}),"\n",(0,s.jsx)(n.p,{children:"There are standard deep links:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<div>\n\t<p>Buy our latest PC parts.</p>\n\t<a href="app://myapp/products/cpu"> </a>\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:"If we declare an this intent-filter:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<data android:scheme="app"\n              android:host="myapp"\n              android:pathPrefix="/products/" />\n'})}),"\n",(0,s.jsx)(n.p,{children:"When the user clicks on the link, the specific product will appear in the application."}),"\n",(0,s.jsx)(n.p,{children:"Security risks may arise from improper implementation."}),"\n",(0,s.jsx)(n.p,{children:"The other type of deep links are Android deeplinks. Let's imagine this example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<div>\n\t<p>Buy our latest PC parts.</p>\n\t<a href="https://www.myapp.com/products/cpu"> </a>\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:"we can define this intent-filter to capture it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'        <data android:scheme="https"\n              android:host="www.myapp.com"\n              android:pathPrefix="/products/" />\n'})}),"\n",(0,s.jsx)(n.p,{children:"If the app that handles the deep link isn't installed, the link will open in a web browser listing the products."}),"\n",(0,s.jsx)(n.h3,{id:"android-debug-bride",children:"Android Debug Bride"}),"\n",(0,s.jsx)(n.p,{children:"Android Debug Bridge (ADB) is a versatile command-line tool that enables communication between a computer and a device. It allows developers to perform tasks like installing and debugging applications, transferring files between the host computer and the device, and accessing the device through a shell."}),"\n",(0,s.jsx)(n.p,{children:"Here, there are some useful adb commands:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Command"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adb help"})}),(0,s.jsx)(n.td,{children:"List all commands."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adb kill-server"})}),(0,s.jsx)(n.td,{children:"Kills the adb server."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adb devices"})}),(0,s.jsx)(n.td,{children:"Lists connected devices."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adb root"})}),(0,s.jsx)(n.td,{children:"Restarts adbd with root permissions."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adb install <apk>"})}),(0,s.jsx)(n.td,{children:"Install app."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adb push <local> <remote>"})}),(0,s.jsx)(n.td,{children:"Copy file/dir to device."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adb pull <remote> <local>"})}),(0,s.jsx)(n.td,{children:"Copy file/dir from device."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adb logcat [options] [filter] [filter]"})}),(0,s.jsx)(n.td,{children:"View device log."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"adb shell"})}),(0,s.jsx)(n.td,{children:"Opens a shell in the device."})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"android-penetration-testing",children:"Android penetration testing"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Enumeration and information gathering"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Gather information about the app and its architecture.\nUnderstand the functionality of the application.\nEnumerate any data structure the app uses that is stored in the local storage."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Static analysis"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Understand the manifest file of the application. Review the app's components, permissions, and configurations.\nDecompile and analyze the application's source code to understand the flow and find potential vulnerabilities.\nExamine native or third-party libraries, frameworks, and dependencies the app uses."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dynamic analysis"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Monitor the application's behavior during runtime. Enumerate the local storage for files and data structures created after performing various functionalities.\nPerform dynamic instrumentation to read the memory of the application during runtime.\nIntercept network traffic and test the app for vulnerabilities such as authentication bypass and insecure data transmission.\nCheck for Server-Side attacks by analyzing API calls and looking for vulnerabilities such as injection and XSS attacks."}),"\n",(0,s.jsx)(n.p,{children:"Suggested tools:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"adb"}),": command-line tool to communicate with Android devices."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"JADX"}),": This tool allows us to reverse engineer an application and view its source code through a graphical interface. It provides the user with a Java-like pseudocode that is close enough to the actual code."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"APKTool"}),": This tool also allows reverse engineering Android applications. It will decompile the source code and decode the resources of the APK file. APKTool also enables us to edit the source code and configuration files, recompile the code, and build the APK file again."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Ghidra"}),": Ghidra is often used to analyze the native C++ libraries loaded to the application."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Burp Suite"}),": to analyze HTTP communication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Frida"}),": A dynamic instrumentation toolkit used by developers, reverse engineers, and security researchers. It enables us to inject snippets of JavaScript or native code into the running processes of Android applications, allowing us to analyze and manipulate them during runtime."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Autopsy"}),": Autopsy will help us investigate disk images of Android devices and let us search for files, databases, calls, messages, and logs, using the provided GUI."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"There's also some automated tools:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MobSF"}),": An automated security testing framework for Android, iOS, and Windows platforms that performs static, dynamic, and malware analysis on mobile applications."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Drozer"}),": A comprehensive security and attack framework that allows us to assess the security of Android applications. It simulates various attack vectors and provides multiple tools to analyze, exploit, and debug Android applications."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Qark"}),": A static code analysis tool that automates the discovery of security vulnerabilities in Android applications. It can also create Proof-of-Concept deployable APKs and ADB commands to exploit the vulnerabilities it finds."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Objection"}),": A runtime mobile exploration toolkit that uses Frida to provide an easy environment for assessing Android and iOS application security. It automates several common tasks, such as bypassing SSL pinning, and users won't be needed to create custom scripts whenever they need to exploit common vulnerabilities."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Medusa"}),": An extensible and modularized framework that automates processes and techniques practiced during the dynamic analysis of Android Applications. Medusa is based on Frida and can analyze and enumerate an app, attack common entry points, and automate processes like application patching, MITM attack, and more. Medusa can add and remove hooks for Java or Native methods and has more than 90 modules that can be combined."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Androbugs"}),": automatically scans Android applications and checks for security issues and vulnerabilities."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);